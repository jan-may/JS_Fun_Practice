const identity = (x) => x;
const addb = (a, b) => a + b;
const subb = (a, b) => a - b;
const mulb = (a, b) => a * b;
const minb = (a, b) => (a < b ? a : b);
const maxb = (a, b) => (a > b ? a : b);
const add = (...nums) => nums.reduce((a, b) => a + b);
const sub = (...nums) => nums.reduce((a, b) => a - b);
const mul = (...nums) => nums.reduce((a, b) => a * b);
const min = (...nums) => nums.reduce((a, b) => (a < b ? a : b));
const max = (...nums) => nums.reduce((a, b) => (a > b ? a : b));
const addRecurse = (...nums) => {
  if (nums.length === 1) return nums[0];
  return nums[0] + addRecurse(...nums.slice(1));
};

module.exports = {
  identity,
  addb,
  subb,
  mulb,
  minb,
  maxb,
  add,
  sub,
  mul,
  min,
  max,
  addRecurse,
  //   mulRecurse,
  //   minRecurse,
  //   maxRecurse,
  //   not,
  //   acc,
  //   accPartial,
  //   accRecurse,
  //   fill,
  //   fillRecurse,
  //   set,
  //   identityf,
  //   addf,
  //   liftf,
  //   pure,
  //   curryb,
  //   curry,
  //   inc,
  //   twiceUnary,
  //   doubl,
  //   square,
  //   twice,
  //   reverseb,
  //   reverse,
  //   composeuTwo,
  //   composeu,
  //   composeb,
  //   composeTwo,
  //   compose,
  //   limitb,
  //   limit,
  //   genFrom,
  //   genTo,
  //   genFromTo,
  //   elementGen,
  //   element,
  //   collect,
  //   filter,
  //   filterTail,
  //   concatTwo,
  //   concat,
  //   concatTail,
  //   gensymf,
  //   gensymff,
  //   fibonaccif,
  //   counter,
  //   revocableb,
  //   revocable,
  //   extract,
  //   m,
  //   addmTwo,
  //   addm,
  //   liftmbM,
  //   liftmb,
  //   liftm,
  //   exp,
  //   expn,
  //   addg,
  //   liftg,
  //   arrayg,
  //   continuizeu,
  //   continuize,
  //   vector,
  //   exploitVector,
  //   vectorSafe,
  //   pubsub,
  //   mapRecurse,
  //   filterRecurse,
};
